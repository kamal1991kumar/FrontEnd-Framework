{"version":3,"sources":["webpack:///./src/js/components/containers/IndexPage/documentation/Git.container.jsx","webpack:///./src/js/core/modules/Http.js","webpack:///./src/js/core/hoc/withRouterConnect.jsx","webpack:///./src/js/views/indexPage/documentation/git.view.jsx"],"names":["__webpack_require__","_lodash","_Http","_withRouterConnect","_git","markdown","showdown","Converter","_GitContainer","props","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","state","docHTML","request","Http","get","hosts","git","then","response","data","payload","url","_response","setState","makeHtml","catch","noop","React","Component","_react2","default","createElement","gitView","_extends","cancel","GitContainer","withRouterConnect","_MessageBus","_constants","_axiosCancel2","axios","responseFormatter","httpResponse","status","headers","timestamp","Date","now","httpError","type","error","message","dispatchMBTransactionEvent","arguments","length","undefined","MessageBus","trigger","HTTP_REQUEST_TRANSACTION","executeRequest","method","config","handler","reqConfig","requestConfig","requestId","shortid","generate","host","path","timeout","onUploadProgress","currentCallback","event","sent","loaded","total","percent","Math","round","onDownloadProgress","received","assign","_config","makeRequestConfig","id","isEmpty","promise","Promise","resolve","reject","_axios2","completed","success","hasOwnProperty","post","put","delete","_reactRedux","_reactRouterDom","mapStateToProps","mapDispatchToProps","withRouter","connect","_react","className","dangerouslySetInnerHTML","__html"],"mappings":"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","file":"js/chunks/b1cpeuizm.chunk.js","sourcesContent":["import React from 'react';\nimport showdown from 'showdown';\nimport { noop } from 'lodash';\n\nimport { Http } from 'core/modules/Http';\nimport { withRouterConnect } from 'core/hoc/withRouterConnect';\n\nimport { gitView as GitView } from 'views/indexPage/documentation/git.view';\n\n// markdown converter\nconst markdown = new showdown.Converter();\n\nclass _GitContainer extends React.Component {\n    constructor( props ) {\n        super( props );\n        \n        this.state = {\n            docHTML: null\n        };\n\n        // `hosts` coming from redux state, using `Promise` version of `Http` service\n        // make sure to store the promise object first to get `cancel` method\n        // below request gets `.json` file from `assets/json`\n        this.request = Http.get( props.hosts.git );\n        this.request.then( ( response ) => {\n\n            // override previous request instance to make cancellation easier,\n            // it will override previous request when it resolves\n            // below request gets `.md` file from `documentation`\n            this.request = Http.get( response.data.payload.data.url );\n            this.request.then( ( _response ) => {\n                this.setState( {\n                    docHTML: markdown.makeHtml( _response.data )\n                } );\n            } ).catch( noop );\n        } ).catch( noop );\n    }\n\n    render() {\n        return (\n            <GitView { ...this.props } docHTML={ this.state.docHTML }/>\n        );\n    }\n\n    componentWillUnmount() {\n        this.request.cancel(); // cancel service XHR\n    }\n}\n\nconst mapStateToProps = ( state ) => {\n    return {\n        hosts: state.hosts\n    };\n};\n\n// `withRouterConnect` HOC will use `withRouter` HOC from `react-router` to pass\n// props from `BrowserRouter` to <_GitContainer> and use `connect` function of React Redux\nexport const GitContainer = withRouterConnect( _GitContainer, mapStateToProps );\n","/**\n * Http utility module which provides easy abstractions over simple Http verbs.\n * Use Http.Get, Http.Post etc. methods to make AJAX network requests.\n * It's easy to integrate; other Http libraries like `fetch` or `jQuery`.\n */\n\n// using axios as current Http library\nimport axios from 'axios';\nimport axiosCancel from 'axios-cancel';\nimport shortid from 'shortid';\nimport { get, isEmpty } from 'lodash';\n\nimport { MessageBus } from 'core/modules/MessageBus';\nimport { HTTP_REQUEST_TRANSACTION } from 'core/constants';\n\n// add `cancel` prototype method\n// to abort `XHR` requests and promise\naxiosCancel( axios );\n\n// Http module\nexport const Http = {};\n\n/*************************************************************/\n\n// HTTP Response formatter\n// return Standard Response Format regardless\n// of any AJAX library is used\nconst responseFormatter = {\n    \n    // when http request resolves successfully\n    success: ( httpResponse ) => {\n        return {\n            data: httpResponse.data,\n            status: httpResponse.status,\n            headers: httpResponse.headers,\n            timestamp: Date.now()\n        };\n    },\n    \n    // when http request returns error\n    error: ( httpError ) => {\n        return {\n            type: get( httpError, 'response.status' ) ? 'HTTP_ERROR' : 'NETWORK_ERROR',\n            error: get( httpError, 'response.data', httpError.message ),\n            status: get( httpError, 'response.status', 0 ),\n            headers: get( httpError, 'response.headers', {} ),\n            timestamp: Date.now()\n        };\n    }\n};\n\n// dispatch message-bus event for HTTP transaction\nconst dispatchMBTransactionEvent = ( type = 'SENT' ) => {\n    MessageBus.trigger( HTTP_REQUEST_TRANSACTION, type );\n};\n\n// `makeRequestConfig` return a fully-fledged config object for axios\n// with some default config values\nconst makeRequestConfig = ( method, config ) => {\n    \n    // default request configuration\n    const requestConfig = {\n        requestId: shortid.generate(),\n        host: 'http://localhost',\n        path: '/',\n        timeout: 60 * 1000 // 1 min\n    };\n\n    // add upload progress listener to config\n    if( config.onUploadProgress && ( 'function' === typeof config.onUploadProgress ) ) {\n        const currentCallback = config.onUploadProgress;\n        \n        config.onUploadProgress = ( event ) => {\n            currentCallback( {\n                sent: event.loaded,\n                total: event.total,\n                percent: 0 !== event.total ? Math.round( ( event.loaded / event.total ) * 100 ) : null\n            } );\n        };\n    }\n\n    // add download progress listener to config\n    if( config.onDownloadProgress && ( 'function' === typeof config.onDownloadProgress ) ) {\n        const currentCallback = config.onDownloadProgress;\n        \n        config.onDownloadProgress = ( event ) => {\n            currentCallback( {\n                received: event.loaded,\n                total: event.total,\n                percent: 0 !== event.total ? Math.round( ( event.loaded / event.total ) * 100 ) : null\n            } );\n        };\n    }\n\n    if( 'string' === typeof config ) {\n        return Object.assign( {}, requestConfig, { method: method, url: config } );\n    } else {\n        const _config = Object.assign( {}, requestConfig, config );\n        return Object.assign( {}, _config, { method: method, url: _config.host + _config.path } );\n    }\n};\n\n// execute request and take response action\nconst executeRequest = ( method, config, handler ) => {\n    \n    // create request configuration for axios\n    const reqConfig =  makeRequestConfig( method, config );\n\n    // send message-bus 'START' event\n    dispatchMBTransactionEvent( { type: 'SENT', id: reqConfig.requestId } );\n\n    // if handler is empty, return promise and cancel function\n    // in an `object`, else just return cancel function\n    if( isEmpty( handler ) ) {\n        const promise =  new Promise( ( resolve, reject ) => {\n            axios( reqConfig ).then( ( response ) => {\n                dispatchMBTransactionEvent( { type: 'SUCCESS', id: reqConfig.requestId } ); // send message-bus 'COMPLETE' event\n                reqConfig.completed = true;\n\n                return resolve( responseFormatter.success( response ) );\n            } )\n            .catch( ( response ) => {\n                dispatchMBTransactionEvent( { type: 'ERROR', id: reqConfig.requestId } ); // send message-bus 'ERROR' event\n                reqConfig.completed = true;\n\n                return reject( responseFormatter.error( response ) );\n            } );\n        } );\n\n        // add cancel method to promise\n        promise.cancel = () => {\n            if( ! reqConfig.completed ) {\n                dispatchMBTransactionEvent( { type: 'ABORT', id: reqConfig.requestId } ); // send message-bus 'ABORT' event\n                axios.cancel( reqConfig.requestId );\n            }\n\n            reqConfig.completed = true;\n        };\n\n        return promise;\n\n    } else {\n\n        // resolve request and call handler callbacks\n        axios( reqConfig ).then( ( response ) => {\n            if( ! reqConfig.completed ) {\n                dispatchMBTransactionEvent( { type: 'SUCCESS', id: reqConfig.requestId } ); // send message-bus 'COMPLETE' event\n                reqConfig.completed = true;\n\n                handler.success( responseFormatter.success( response ) );\n            }\n        } )\n        .catch( ( response ) => {\n            if( ! reqConfig.completed ) {\n                dispatchMBTransactionEvent( { type: 'ERROR', id: reqConfig.requestId } ); // send message-bus 'ERROR' event\n                reqConfig.completed = true;\n\n                if( handler.hasOwnProperty( 'error' ) && 'function' === typeof handler.error ) {\n                    handler.error( responseFormatter.error( response ) );\n                }\n            }\n        } );\n\n        // return cancel function\n        return () => {\n            if( ! reqConfig.completed ) {\n                dispatchMBTransactionEvent( { type: 'ABORT', id: reqConfig.requestId } ); // send message-bus 'ABORT' event\n                axios.cancel( reqConfig.requestId );\n            }\n            \n            reqConfig.completed = true;\n        };\n    }\n};\n\n/*************************************************************/\n\n\n// HTTP GET method\n// Use: http.get( config, {success, error} ) => cancelFunction\n// Use: http.get( config ) => { promise, cancel }\nHttp.get = ( config, handler ) => {\n    return executeRequest( 'GET', config, handler );\n};\n\n// HTTP POST method\n// Use: http.post( config, {success, error} ) => cancelFunction\n// Use: http.post( config ) => { promise, cancel }\nHttp.post = ( config, handler ) => {\n    return executeRequest( 'POST', config, handler );\n};\n\n// HTTP PUT method\n// Use: http.put( config, {success, error} ) => cancelFunction\n// Use: http.put( config ) => { promise, cancel }\nHttp.put = ( config, handler ) => {\n    return executeRequest( 'PUT', config, handler );\n};\n\n// HTTP DELETE method\n// Use: http.delete( config, {success, error} ) => cancelFunction\n// Use: http.delete( config ) => { promise, cancel }\nHttp.delete = ( config, handler ) => {\n    return executeRequest( 'DELETE', config, handler );\n};\n","/**\n * withStore( Component, mapStateToProps, mapDispatchToProps ) returns a component\n * with Route props and redux connect functionality.\n */\n\nimport { connect } from 'react-redux';\nimport { withRouter } from 'react-router-dom';\n\n// export function which wraps component with `withRouter` and `connect`\nexport const withRouterConnect = ( Component, mapStateToProps = {}, mapDispatchToProps = {} ) => {\n    return withRouter(\n        connect( mapStateToProps, mapDispatchToProps )( Component )\n    );\n};\n","import React from 'react';\n\nexport const gitView = ( props ) => {\n    return (\n        <div className='markdown-body'>\n            {\n                props.docHTML ? <div dangerouslySetInnerHTML={ { __html: props.docHTML } }></div> : 'loading...'\n            }\n        </div>\n    );\n};\n"],"sourceRoot":""}